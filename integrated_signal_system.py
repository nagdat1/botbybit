#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
ÙŠØ¯Ù…Ø¬ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
"""

import logging
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
from advanced_signal_manager import advanced_signal_manager, process_signal, set_user_settings

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
try:
    from signal_executor import SignalExecutor
    from signal_converter import convert_simple_signal
    from signal_id_manager import get_signal_id_manager
    EXISTING_SYSTEM_AVAILABLE = True
    logger = logging.getLogger(__name__)
    logger.info("âœ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ù…ØªØ§Ø­")
except ImportError as e:
    EXISTING_SYSTEM_AVAILABLE = False
    logger = logging.getLogger(__name__)
    logger.warning(f"âš ï¸ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ØºÙŠØ± Ù…ØªØ§Ø­: {e}")

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
try:
    from user_manager import user_manager
    USER_MANAGER_AVAILABLE = True
except ImportError as e:
    USER_MANAGER_AVAILABLE = False
    logger.warning(f"âš ï¸ Ù…Ø¯ÙŠØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ØºÙŠØ± Ù…ØªØ§Ø­: {e}")

class IntegratedSignalSystem:
    """Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.signal_executor = SignalExecutor() if EXISTING_SYSTEM_AVAILABLE else None
        self.signal_id_manager = get_signal_id_manager() if EXISTING_SYSTEM_AVAILABLE else None
        
        self.logger.info("ðŸš€ ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª")
    
    async def process_signal_complete(self, signal_data: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """
        Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¨Ø´ÙƒÙ„ Ù…ØªÙƒØ§Ù…Ù„
        
        Args:
            signal_data: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
            user_id: Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            
        Returns:
            Ù†ØªÙŠØ¬Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
        """
        try:
            self.logger.info(f"ðŸ”„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø´Ø§Ø±Ø© Ù…ØªÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {signal_data}")
            
            # 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
            if not self._validate_signal_format(signal_data):
                return {
                    'success': False,
                    'message': 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ØºÙŠØ± ØµØ­ÙŠØ­',
                    'error': 'INVALID_FORMAT'
                }
            
            # 2. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            user_settings = self._get_user_settings(user_id)
            
            # 3. ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
            advanced_settings = self._convert_to_advanced_settings(user_settings)
            set_user_settings(user_id, advanced_settings)
            
            # 4. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¨Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
            advanced_result = process_signal(signal_data, user_id)
            
            # 5. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø­Ù‚ÙŠÙ‚ÙŠØŒ ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø© Ø¹Ø¨Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
            if user_settings.get('account_type') == 'real' and advanced_result.get('success'):
                execution_result = await self._execute_real_trade(signal_data, user_settings, user_id)
                
                # Ø¯Ù…Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
                advanced_result['execution_result'] = execution_result
                
                if not execution_result.get('success'):
                    advanced_result['success'] = False
                    advanced_result['message'] = f"ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªÙ†ÙÙŠØ°: {execution_result.get('message', '')}"
            
            # 6. Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
            advanced_result['user_id'] = user_id
            advanced_result['timestamp'] = datetime.now().isoformat()
            advanced_result['system_version'] = 'integrated_v1.0'
            
            self.logger.info(f"âœ… ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­: {advanced_result}")
            return advanced_result
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©: {e}")
            return {
                'success': False,
                'message': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©: {str(e)}',
                'error': 'INTEGRATION_ERROR',
                'user_id': user_id
            }
    
    def _validate_signal_format(self, signal_data: Dict[str, Any]) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©"""
        try:
            required_fields = ['signal', 'symbol', 'id']
            for field in required_fields:
                if field not in signal_data or not signal_data[field]:
                    self.logger.error(f"âŒ Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ '{field}' Ù…ÙÙ‚ÙˆØ¯")
                    return False
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
            signal_type = signal_data['signal'].lower()
            valid_signals = ['buy', 'sell', 'close', 'partial_close']
            if signal_type not in valid_signals:
                self.logger.error(f"âŒ Ù†ÙˆØ¹ Ø¥Ø´Ø§Ø±Ø© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…: {signal_type}")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©: {e}")
            return False
    
    def _get_user_settings(self, user_id: int) -> Dict[str, Any]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        try:
            if USER_MANAGER_AVAILABLE:
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
                user_data = user_manager.get_user_data(user_id)
                if user_data:
                    return user_data.get('settings', {})
            
            # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
            return {
                'account_type': 'demo',
                'market_type': 'spot',
                'exchange': 'bybit',
                'trade_amount': 100.0,
                'leverage': 10,
                'link_by_id': True
            }
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")
            return {
                'account_type': 'demo',
                'market_type': 'spot',
                'exchange': 'bybit',
                'trade_amount': 100.0,
                'leverage': 10,
                'link_by_id': True
            }
    
    def _convert_to_advanced_settings(self, user_settings: Dict[str, Any]) -> Dict[str, Any]:
        """ØªØ­ÙˆÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
        try:
            advanced_settings = {
                'account_type': user_settings.get('account_type', 'demo'),
                'market_type': user_settings.get('market_type', 'spot'),
                'exchange': user_settings.get('exchange', 'bybit'),
                'trade_amount': float(user_settings.get('trade_amount', 100.0)),
                'leverage': int(user_settings.get('leverage', 10)),
                'link_by_id': bool(user_settings.get('link_by_id', True)),
                'language': user_settings.get('language', 'ar')
            }
            
            self.logger.info(f"âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {advanced_settings}")
            return advanced_settings
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: {e}")
            return {
                'account_type': 'demo',
                'market_type': 'spot',
                'exchange': 'bybit',
                'trade_amount': 100.0,
                'leverage': 10,
                'link_by_id': True,
                'language': 'ar'
            }
    
    async def _execute_real_trade(self, signal_data: Dict[str, Any], user_settings: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """ØªÙ†ÙÙŠØ° ØµÙÙ‚Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ© Ø¹Ø¨Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯"""
        try:
            if not EXISTING_SYSTEM_AVAILABLE or not self.signal_executor:
                return {
                    'success': False,
                    'message': 'Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ',
                    'error': 'EXISTING_SYSTEM_UNAVAILABLE'
                }
            
            self.logger.info(f"ðŸŒ ØªÙ†ÙÙŠØ° ØµÙÙ‚Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")
            
            # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
            converted_signal = convert_simple_signal(signal_data, user_settings)
            
            if not converted_signal:
                return {
                    'success': False,
                    'message': 'ÙØ´Ù„ ÙÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©',
                    'error': 'SIGNAL_CONVERSION_FAILED'
                }
            
            # ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø©
            execution_result = await self.signal_executor.execute_signal(user_id, converted_signal, user_settings)
            
            self.logger.info(f"âœ… Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: {execution_result}")
            return execution_result
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©: {e}")
            return {
                'success': False,
                'message': f'Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©: {str(e)}',
                'error': 'REAL_EXECUTION_ERROR'
            }
    
    def get_user_status(self, user_id: int) -> Dict[str, Any]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        try:
            # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            user_settings = self._get_user_settings(user_id)
            
            # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
            from advanced_signal_manager import get_user_statistics
            stats = get_user_statistics(user_id)
            
            # ØµÙÙ‚Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            from advanced_signal_manager import get_user_positions
            positions = get_user_positions(user_id)
            
            return {
                'user_id': user_id,
                'settings': user_settings,
                'statistics': stats,
                'positions': positions,
                'system_status': 'active',
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")
            return {
                'user_id': user_id,
                'error': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø©: {str(e)}',
                'timestamp': datetime.now().isoformat()
            }
    
    def update_user_settings(self, user_id: int, new_settings: Dict[str, Any]) -> Dict[str, Any]:
        """ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        try:
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
            advanced_settings = self._convert_to_advanced_settings(new_settings)
            success = set_user_settings(user_id, advanced_settings)
            
            if success:
                self.logger.info(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")
                return {
                    'success': True,
                    'message': 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­',
                    'settings': advanced_settings
                }
            else:
                return {
                    'success': False,
                    'message': 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
                    'error': 'UPDATE_FAILED'
                }
                
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")
            return {
                'success': False,
                'message': f'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: {str(e)}',
                'error': 'UPDATE_ERROR'
            }
    
    def get_system_info(self) -> Dict[str, Any]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…"""
        try:
            return {
                'system_name': 'Integrated Signal System',
                'version': '1.0.0',
                'features': [
                    'Advanced Signal Management',
                    'ID-based Signal Linking',
                    'Account Type Support (Demo/Real)',
                    'Market Type Support (Spot/Futures)',
                    'Optional Signal Linking',
                    'Real-time Execution',
                    'Position Tracking',
                    'User Statistics'
                ],
                'supported_signals': ['buy', 'sell', 'close', 'partial_close'],
                'supported_exchanges': ['bybit', 'mexc'],
                'supported_markets': ['spot', 'futures'],
                'supported_accounts': ['demo', 'real'],
                'existing_system_available': EXISTING_SYSTEM_AVAILABLE,
                'user_manager_available': USER_MANAGER_AVAILABLE,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…: {e}")
            return {
                'error': f'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…: {str(e)}',
                'timestamp': datetime.now().isoformat()
            }


# Ù…Ø«ÙŠÙ„ Ø¹Ø§Ù… Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„
integrated_signal_system = IntegratedSignalSystem()


# Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ø±ÙŠØ¹
async def process_signal_integrated(signal_data: Dict[str, Any], user_id: int) -> Dict[str, Any]:
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø´Ø§Ø±Ø© Ù…ØªÙƒØ§Ù…Ù„Ø©"""
    return await integrated_signal_system.process_signal_complete(signal_data, user_id)


def get_user_status_integrated(user_id: int) -> Dict[str, Any]:
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©"""
    return integrated_signal_system.get_user_status(user_id)


def update_user_settings_integrated(user_id: int, settings: Dict[str, Any]) -> Dict[str, Any]:
    """ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©"""
    return integrated_signal_system.update_user_settings(user_id, settings)


def get_system_info_integrated() -> Dict[str, Any]:
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„"""
    return integrated_signal_system.get_system_info()


if __name__ == "__main__":
    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„
    print("=" * 80)
    print("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª")
    print("=" * 80)
    
    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
    system_info = get_system_info_integrated()
    print(f"ðŸ“‹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…: {system_info}")
    
    # Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
    user_id = 12345
    
    # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    settings = {
        'account_type': 'demo',
        'market_type': 'spot',
        'exchange': 'bybit',
        'trade_amount': 100.0,
        'leverage': 10,
        'link_by_id': True
    }
    
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    update_result = update_user_settings_integrated(user_id, settings)
    print(f"âœ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: {update_result}")
    
    # Ø£Ù…Ø«Ù„Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
    test_signals = [
        {'signal': 'buy', 'symbol': 'BTCUSDT', 'id': 'TV_B01'},
        {'signal': 'sell', 'symbol': 'BTCUSDT', 'id': 'TV_S01'},
        {'signal': 'close', 'symbol': 'BTCUSDT', 'id': 'TV_C01'},
        {'signal': 'partial_close', 'symbol': 'BTCUSDT', 'id': 'TV_PC01', 'percentage': 50}
    ]
    
    async def test_signals():
        for signal in test_signals:
            print(f"\nðŸ“¥ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©: {signal}")
            result = await process_signal_integrated(signal, user_id)
            print(f"ðŸ“¤ Ø§Ù„Ù†ØªÙŠØ¬Ø©: {result}")
        
        # Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        user_status = get_user_status_integrated(user_id)
        print(f"\nðŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_status}")
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
    asyncio.run(test_signals())
