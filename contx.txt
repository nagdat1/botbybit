### سياق الإشارات وتشغيل البوت

- قبل تنفيذ أي إشارة، يحدد النظام نوع الحساب النشط: تجريبي أو حقيقي.
- الحساب الحقيقي يرسل الأوامر للمنصة عبر API. الحساب التجريبي يُنفذ داخليًا فقط للتجارب وتتبع الصفقات.

---

### 1) اختيار نوع الحساب

- account_type: "real" للحقيقي، "demo" للتجريبي
- لا يتم إظهار نوع الحساب في أي تنبيه للمستخدم

```python
account_type = "real"   # حقيقي
# أو
account_type = "demo"   # تجريبي
```

---

### 2) أمثلة الإشارات (ثابتة للمستخدم)

هذه البنية لا تتغير في تنبيهات المستخدم.

- شراء

```json
{
  "signal": "buy",
  "symbol": "BTCUSDT",
  "id": "TV_B01"
}
```

- بيع

```json
{
  "signal": "sell",
  "symbol": "BTCUSDT",
  "id": "TV_S01"
}
```

- إغلاق كامل

```json
{
  "signal": "close",
  "symbol": "BTCUSDT",
  "id": "TV_C01"
}
```

- إغلاق جزئي (مثال 50%)

```json
{
  "signal": "partial_close",
  "symbol": "BTCUSDT",
  "percentage": 50,
  "id": "TV_PC01"
}
```

---

### 3) الربط الاختياري عبر الـ ID

- كل إشارة تحتوي على id فريد.
- المتغير link_by_id يحدد منطق الربط:

```python
link_by_id = True   # إشارات بنفس الـ ID تُدار كصفقة واحدة (تعزيز/تقليل)
link_by_id = False  # كل إشارة تفتح صفقة مستقلة
```

- المنطق المختصر:
    - عند True: نفس ID → نفس الصفقة. يعزز أو يُغلق جزئيًا/كليًا تلك الصفقة.
    - عند False: كل إشارة تعامل كصفقة جديدة مستقلة.

---

### 4) قواعد تنفيذ الإشارات

- شراء buy
    - يفتح صفقة جديدة أو يعزز صفقة موجودة إذا link_by_id=True.
    - تجاهل الإشارة إذا كانت بنفس ID ولكن بعكس الاتجاه المفتوح.
- بيع sell
    - العقود الآجلة Futures: فتح/تعزيز Short.
    - السبوت Spot: بيع من الرصيد المتاح فقط. لا يوجد Short.
- إغلاق كامل close
    - يغلق الصفقة المرتبطة بنفس ID عندما link_by_id=True.
- إغلاق جزئي partial_close
    - يغلق نسبة محددة من الصفقة المرتبطة بنفس ID عندما link_by_id=True.

---

### 5) الفرق بين Spot و Futures

| البند | Spot | Futures |
| --- | --- | --- |
| الشراء | شراء الأصل فعليًا | فتح/تعزيز Long |
| البيع | بيع الرصيد الموجود فقط | فتح/تعزيز Short |
| الإغلاق الكامل | بيع كامل الرصيد | إغلاق كامل الصفقة |
| الإغلاق الجزئي | بيع نسبة محددة من الرصيد | تقليل جزء من حجم الصفقة |
- ملاحظة: نوع الحساب يستخدم داخليًا فقط ولا يظهر في التنبيهات.

---

### 6) إدارة الحسابات وخواص العزل

- لكل من Spot و Futures حساب مستقل للحالة والصفقات.
- تبديل الحساب لا يؤثر على صفقات الحساب الآخر ولا يغلقها.
- الإشارات الجديدة تُنفذ فقط على الحساب النشط حاليًا.

---

### 7) خطوات التنفيذ الآمن

1. حدّد الحساب النشط: تجريبي/حقيقي وSpot/Futures.
2. استخدم الـ ID للربط فقط إذا link_by_id=True.
3. في Spot، لا تنفذ بيعًا دون رصيد كافٍ.
4. لا تُظهر نوع الحساب في أي تنبيه.
5. احتفظ بسجل لكل صفقة لمنع التكرار والتضارب.
6. التجريبي = تنفيذ داخلي. الحقيقي = تنفيذ عبر API.

---

### 8) نقاط تكامل واعتبارات إضافية

- اللقطات Snapshots للحقيقي اختيارية حسب الإعدادات.
- التخزين التجريبي مثال: trades_demo.json، إضافةً إلى تتبع الأرصدة.
- دعم الربط عبر Telegram والويب هوك وتحديث الرسائل.

---

### 9) نموذج System Prompt جاهز

### تعليمات الإيجنت لتشغيل إشارات التداول

- نفّذ الإشارات وفق النوعين Spot/Futures مع احترام link_by_id.
- الحساب الحقيقي يرسل أوامر API. التجريبي داخلي بالكامل.
- لا تعرض نوع الحساب للمستخدم. امنع بيع Spot دون رصيد.
- استخدم نفس ID لربط الإشارات كصفقة واحدة عند تفعيل الربط.
- سجّل كل العمليات لتفادي التكرار والتضارب.

> إذا رغبت، يمكن تخصيص نسخة موسعة لسيناريوهات إضافية مثل إدارة الرافعة، TP/SL الافتراضية، أو سياسات التبريد والتعزيز.
> 

---

### 10) آلية عمل أدوات المنصّة بالتفصيل

- أوامر السوق Market
    - تنفّذ بالسعر الحالي. مناسبة للدخول أو الخروج السريع. قد يحدث انزلاق سعري.
- الأوامر المحددة Limit
    - تحدد سعرًا للتنفيذ. تضمن السعر وليس التنفيذ. استخدم "Post-Only" لتجنّب التحويل إلى Market.
- الإيقاف Stop و Trigger
    - شرط تشغيل الأمر عند الوصول لسعر معيّن. أنواع شائعة: Stop Market و Stop Limit.
- جني الأرباح TP وإيقاف الخسارة SL
    - يمكن ضبطهما كشرطين مستقلّين أو كأوامر مرفقة (OCO). يُفضَّل حفظ القيم الافتراضية في الإعدادات.
- وقت التنفيذ Time in Force
    - GTC: يظل الأمر فعالًا حتى يُنفّذ أو يُلغى.
    - IOC: ينفّذ الجزء المتاح فورًا ويلغي الباقي.
    - FOK: ينفّذ كامل الكمية فورًا أو يُلغى بالكامل.
- خصائص متقدمة
    - Reduce-Only: لا يزيد حجم الصفقة، يستخدم فقط للتقليص أو الإغلاق.
    - Close-On-Trigger: يضمن أن أمر الإغلاق لن يزيد المخاطر حتى مع قيود الهامش.
    - Hedge vs One-Way: وضع التحوّط يسمح بصفقتي Long وShort على نفس الرمز. وضع الاتجاه الواحد يدمجها في صفقة صافية.
- إعدادات الهامش والرافعة (Futures)
    - Cross: يشارك رصيد الحساب في تغطية الهامش.
    - Isolated: يعزل الهامش على الصفقة فقط.
    - الرافعة: تضاعف التعرض والمخاطر. حسّاس لفرق التصفية.

### 11) الفرق المفصّل بين Spot و Futures

### 11.1) التكامل عبر API للحساب الحقيقي (Bybit و MEXC)

- الهدف: جعل سلوك التنفيذ في الحساب الحقيقي يطابق ما يحدث فعليًا على منصات Bybit وMEXC.

### أ) المصادقة والبيئة

- بيئات
    - Mainnet: تنفيذ حقيقي على حسابك.
    - Testnet (إن توفرت): للاختبار بدون أموال حقيقية.
- مفاتيح API
    - key, secret، وصلاحيات: التداول فقط، بدون سحب.
- التوقيع
    - Bybit: HMAC SHA256 على السلسلة المرتبة للبارامترات + timestamp، في Header.
    - MEXC: HMAC SHA256 على Query String أو Body مع timestamp وrecvWindow.

### ب) أنواع الأوامر والحقول الأساسية

- أنواع مدعومة
    - Market، Limit، Stop Market، Stop Limit، OCO للـ TP/SL
- حقول عامة
    - symbol، side، type، qty/size، price (للـ Limit)، triggerPrice (للأوامر الشرطية)، tif
- أعلام مهمة (Futures)
    - reduce_only، close_on_trigger، positionMode: one-way | hedge
- اختيار محرّك المحفّز Trigger
    - last | index | mark إن كان متاحًا. الإعداد الافتراضي: mark.

### ج) مطابقة السياسات بين البوت والمنصّات

- Spot
    - buy: أمر Market أو Limit حسب السياسة.
    - sell: بيع من الرصيد فقط. رفض إذا لا يوجد رصيد كافٍ.
- Futures
    - buy → Long، sell → Short. كلاهما يمكن Market/Limit.
    - الإغلاقات: دائمًا reduce_only. لا تحويل إغلاق إلى تعزيز.
    - Close-On-Trigger لأوامر الإغلاق الشرطية.
- OCO للـ TP/SL
    - ربط الهدف والوقف بحيث تنفيذ واحد يلغي الآخر.
- TIF
    - GTC افتراضي. دعم IOC/FOK عند الحاجة.
- Post-Only (للـ Limit)
    - منع التحوّل إلى Taker. رفض إذا كان سيتنّفذ فورًا.

### د) خرائط الحقول لكل منصة

| المفهوم | Bybit | MEXC |
| --- | --- | --- |
| الكمية | qty أو size (حسب سوق spot/futures) | quantity |
| السعر | price | price |
| النوع | type: Market|Limit | type: MARKET|LIMIT |
| الزمن TIF | timeInForce: GTC|IOC|FOK | timeInForce: GTC|IOC|FOK |
| المحفّز الشرطي | triggerPrice (+ triggerDirection) | stopPrice |
| Reduce-Only | reduceOnly: true|false | reduceOnly: true|false |
| Close-On-Trigger | closeOnTrigger: true|false | مدعوم بسلوك الإغلاق الشرطي |
| وضع الصفقة | positionIdx/positionMode | positionMode |

### ه) أمثلة طلبات تنفيذ واقعية

- Bybit Futures: فتح Long Market مع id وربط TP/SL

```json
{
  "action": "place_order",
  "exchange": "bybit",
  "market": "futures",
  "symbol": "BTCUSDT",
  "side": "Buy",
  "type": "Market",
  "size": 0.01,
  "tif": "GTC",
  "link_id": "LONG_A",
  "tp": 70500,
  "sl": 69000,
  "reduce_only": false,
  "close_on_trigger": false
}
```

- Bybit Futures: إغلاق جزئي 30% مع reduce_only

```json
{
  "action": "close_partial",
  "exchange": "bybit",
  "market": "futures",
  "symbol": "BTCUSDT",
  "link_id": "LONG_A",
  "percentage": 30,
  "reduce_only": true,
  "close_on_trigger": true
}
```

- MEXC Spot: شراء Limit مع Post-Only

```json
{
  "action": "place_order",
  "exchange": "mexc",
  "market": "spot",
  "symbol": "ETHUSDT",
  "side": "BUY",
  "type": "LIMIT",
  "quantity": 0.5,
  "price": 2700.0,
  "timeInForce": "GTC",
  "post_only": true
}
```

- MEXC Futures: أمر Stop Market لإغلاق الصفقة

```json
{
  "action": "place_order",
  "exchange": "mexc",
  "market": "futures",
  "symbol": "BTCUSDT",
  "side": "SELL",
  "type": "MARKET",
  "stopPrice": 69000,
  "reduce_only": true
}
```

### و) القيود والدقة

- احترام tick_size وqty_step وmin_notional لكل رمز.
- تحويل الكميات إلى الدقّة الصحيحة قبل الإرسال.

### ز) حدود المعدّل وإعادة المحاولة

- Queue داخلي لاحترام Rate Limits لكلا المنصتين.
- Retry مع backoff لمشاكل الشبكة.
- إلغاء تلقائي للأوامر المعلّقة عند تبدّل الحالة.

### ح) إدارة الأخطاء النموذجية

- رموز أخطاء شائعة
    - مصادقة غير صحيحة، رصيد غير كافٍ، كمية أقل من الحد الأدنى، تجاوز المعدّل.
- سياسات التعامل
    - توحيد رسائل الخطأ وشرح سبب الرفض.
    - اقتراح تعديل الكمية أو السعر عند الحاجة.

### ط) إشعارات Telegram (حساب حقيقي)

- عند الفتح: عرض الرمز والحجم والسعر التقريبي وid إن وجد أو المُولّد.
- عند الإغلاق الجزئي/الكامل: نسبة أو حجم الإغلاق، وبقاء reduce_only مفعّل.
- إخفاء نوع الحساب دائمًا في الرسائل.

| الجانب | Spot | Futures |
| --- | --- | --- |
| طبيعة الأصول | تملك الأصل فعليًا | عقد مشتق يرتبط بالسعر (لا تملك الأصل) |
| الاتجاهات الممكنة | Long فقط. لا يوجد Short بدون اقتراض | Long و Short بسهولة |
| المخاطر والتصفية | لا توجد تصفية. الخسارة محدودة برصيد الأصل | توجد تصفية حسب الهامش والرافعة |
| الهامش والرافعة | غير متاحين عادةً | Cross أو Isolated + رافعة قابلة للضبط |
| الرسوم والفروقات | رسوم تداول فقط | رسوم + تمويل (Funding) دوري للمراكز المفتوحة |
| أوامر الإغلاق | بيع كامل أو جزئي من الرصيد | Reduce-Only و Close-On-Trigger لإدارة الإغلاق الآمن |
| الملاءمة | استثمار وتحوّط بسيط | تداول نشط وإستراتيجيات معقدة باستخدام الرافعة |

---

### 12) ربط الصفقات بالمنصّة وفق منهجية ID

### 12.4) جعل id اختياريًا + توليد تلقائي عند عدم الإرسال

- الهدف: id يُستخدم فقط لإدارة الصفقة لاحقًا عبر الإشعارات مثل TP/SL وclose وpartial_close.
- إن لم تُرسل id في إشارات الفتح، يقوم البوت بتوليد id تلقائي وربطه بالصفقة.
- كيفية التوليد:
    - الصيغة المقترحة: <SYMBOL>-<YYYYMMDD>-<HHMMSS>-<RAND4>
    - مثال: BTCUSDT-20251019-031540-7KQ2
    - يجب أن يكون فريدًا داخل الحساب والسوق (Spot/Futures).
- التعريض للمستخدم:
    - بعد كل فتح صفقة بلا id، يرسل البوت رسالة تتضمن id الذي تم توليده كي تستخدمه لاحقًا في الإغلاقات والأهداف.
    - في التليغرام: "تم فتح صفقة BTCUSDT. id: BTCUSDT-20251019-031540-7KQ2".
- القواعد:
    
    1) partial_close أو close أو TP/SL يجب أن تتضمن id لاستهداف الصفقة الصحيحة عندما توجد عدة صفقات على نفس الرمز.
    
    2) إذا لم يُذكر id وكان هناك صفقة واحدة فقط للرمز في نفس السوق، يمكن تطبيق الإدارة عليها كافتراضي، وإلا تُرفض العملية برسالة توضيح.
    
    3) فصل الاتجاهات ثابت: Long وShort لا يُدمجان حتى لو كان id نفسه. يُفضّل إرسال "side" عند الغموض.
    
- مثال تدفق عملي
    
    1) فتح بدون id:
    

```json
{"signal":"buy","symbol":"BTCUSDT"}
```

→ البوت يولّد: BTCUSDT-20251019-031540-7KQ2 ويبلغك به.

2) لاحقًا إغلاق جزئي لنفس الصفقة:

```json
{"signal":"partial_close","symbol":"BTCUSDT","percentage":30,"id":"BTCUSDT-20251019-031540-7KQ2"}
```

3) وضع هدف ربح (مثال كمعلومة سياسات):

```json
{"signal":"tp","symbol":"BTCUSDT","price":70000,"id":"BTCUSDT-20251019-031540-7KQ2"}
```

### 12.3) استخدام id في الإغلاق الجزئي (Partial Close)

- المبدأ:
    - يتم تطبيق partial_close فقط على الصفقة التي يحددها id.
    - إن لم يُذكر id، يُطبّق الإغلاق الجزئي على صفقة الرمز المجمّعة الافتراضية، إن وُجدت.
- قواعد دقيقة:
    
    1) إذا وُجدت عدة صفقات على نفس الرمز وكلٌ لها id مختلف، فيجب ذكر id في partial_close لتحديد أي صفقة تُغلق جزئيًا.
    
    2) إن لم يوجد id في partial_close والرمز لديه صفقة واحدة فقط مجمّعة، تُطبق على هذه الصفقة.
    
    3) في Futures، partial_close يعمل مع Reduce-Only ولا يغيّر الاتجاه. Long يبقى Long بعد التقليص. Short يبقى Short.
    
    4) في Spot، partial_close يبيع نسبة من الرصيد المتاح للرمز.
    
- أمثلة Spot:

```json
{"signal":"buy","symbol":"ETHUSDT"}
{"signal":"buy","symbol":"ETHUSDT"}
{"signal":"partial_close","symbol":"ETHUSDT","percentage":40}
```

يُغلق 40% من صفقة ETHUSDT المجمّعة لأن لا يوجد id، والرمز صفقة واحدة.

- أمثلة Futures مع تعدد الهوّيات:

```json
{"signal":"buy","symbol":"BTCUSDT","id":"LONG_A"}
{"signal":"buy","symbol":"BTCUSDT","id":"LONG_B"}
{"signal":"partial_close","symbol":"BTCUSDT","percentage":25,"id":"LONG_B"}
```

يُقلّص فقط مركز LONG_B بنسبة 25% ولا يمس LONG_A.

- مثال Futures لاتجاهين مختلفين على نفس id:

```json
{"signal":"buy","symbol":"BTCUSDT","id":"X"}      // يفتح Long X
{"signal":"sell","symbol":"BTCUSDT","id":"X"}     // يفتح Short مستقل X
{"signal":"partial_close","symbol":"BTCUSDT","percentage":50,"id":"X"}
```

يجب أن يحدد النظام أي اتجاه يُدار بالـ id عند الإغلاق الجزئي. التنفيذ المعتمد لدينا:

- إذا وُجد Long وShort بنفس id، نطلب تطابق الاتجاه سياقيًا.
- الحل الآمن: نستخدم سياسة التحديد بالسياق الحالي أو نرفض مع رسالة توضيح إن كان غامضًا. يُفضَّل أن تُرسل partial_close مع حقل "side" اختياريًا لتحديد Long أو Short:

```json
{"signal":"partial_close","symbol":"BTCUSDT","percentage":50,"id":"X","side":"Long"}
```

- تلميحات تنفيذية:
    - always reduce_only في Futures.
    - التحقق من الرصيد في Spot قبل التنفيذ.
    - حد أدنى للكمية بعد التقليص حسب tick_size وqty_step.

### خلاصة منطق id (مختصر وواضح)

- الهدف من id: تحديد الصفقة المستهدفة لأوامر الإدارة فقط.
- تكرار id لا يعني إغلاقًا تلقائيًا أبدًا.
- الإدارة تتم فقط عندما تكون الإشارة من نوع close أو partial_close أو TP/SL.
- التعزيز: buy بنفس الرمز ومع نفس id يعني تعزيز نفس الصفقة.
- فصل الاتجاهات: Long وShort يبقيان منفصلين حتى لو شاركا نفس id. الإغلاق لكل اتجاه لا يتم إلا بإشارته.

### أمثلة إشارات دقيقة

- فتح وتعزيز Spot مع إدارة لاحقة

```json
{"signal":"buy","symbol":"BTCUSDT"}
{"signal":"buy","symbol":"BTCUSDT"}
{"signal":"partial_close","symbol":"BTCUSDT","percentage":25,"id":"BTC_MAIN"}
```

- فتح Long Futures ثم إدارة باستخدام id

```json
{"signal":"buy","symbol":"BTCUSDT","id":"LONG_A"}
{"signal":"buy","symbol":"BTCUSDT","id":"LONG_A"}
{"signal":"close","symbol":"BTCUSDT","id":"LONG_A"}
```

- فتح Short مستقل حتى لو نفس id (لا يغلق الـ Long)

```json
{"signal":"sell","symbol":"BTCUSDT","id":"LONG_A"}
```

هذا يفتح Short مستقل. إغلاق الـ Long يبقى عبر:

```json
{"signal":"close","symbol":"BTCUSDT","id":"LONG_A"}
```

### 12.1) منطق تلقي وتجميع الصفقات بالرمز مع ID اختياري

- الأساس بالمنصّة (سلوك التجميع بالرمز)
    - إذا وصلت إشارة شراء مرتين بنفس الرمز نفسه، تُجمع الكميات في صفقة واحدة للرمز نفسه.
    - إذا كان الرمز مختلفًا، تُفتح صفقات متعددة وتظهر كل صفقة على حدة في الصفقات المفتوحة.
- دور الـ ID كخيار اختياري في الإشارة
    - وجود id في الإشارة يجعل الإشارات اللاحقة بنفس id تشير إلى "نفس الصفقة المنطقية" لأغراض الإدارة فقط: إغلاق كامل، إغلاق جزئي، أو تنفيذ أهداف/وقف خسارة.
    - إذا تكرر نفس الاسم id تلقائيًا، يفهم البوت أن العمل المطلوب هو على الصفقة المرتبطة بهذا id.
- فصل الاتجاهات حتى مع نفس id
    - إذا كانت الصفقة الأصلية شراء (Spot buy أو Futures Long) ثم وصلت إشارة بيع (Spot sell أو Futures Short) بنفس id:
        - يتم التعامل مع كل اتجاه على حدة. لا يُمزج Long مع Short حتى لو كان id واحدًا.
        - الاستفادة من id هنا مقتصرة على أوامر الإدارة الخاصة بتلك الصفقة فقط، مثل إغلاقاتها أو جني أرباحها.
- قواعد تنفيذ موجزة
    
    1) buy نفس الرمز دون id: تجميع للكمية في صفقة الرمز.
    
    2) buy نفس الرمز مع id ثابت: تعزيز نفس الكيان المنطقي لهذا id.
    
    3) buy برمز مختلف: صفقة جديدة مستقلة.
    
    4) close أو partial_close مع id: تُطبق فقط على الصفقة المرتبطة بذلك id.
    
    5) sell على Spot مع عدم وجود رصيد كافٍ: رفض التنفيذ.
    
    6) sell على Futures حتى لو بنفس id لصفقة Long: تُدار كاتجاه مستقل (Short)، ولا تُدمج مع Long.
    
- أمثلة سريعة
    - مثال A (Spot):
        - إشارة: buy BTCUSDT → تُفتح صفقة BTCUSDT.
        - إشارة: buy BTCUSDT → تُعزَّز نفس صفقة BTCUSDT (تجميع).
        - إشارة: partial_close 30% id=TV_BTC → تُقلّص الصفقة المرتبطة بـ id=TV_BTC فقط إن وُجد.
    - مثال B (Futures):
        - إشارة: buy BTCUSDT id=TV_X → Long BTCUSDT.
        - إشارة: buy BTCUSDT id=TV_X → تعزيز Long نفسها.
        - إشارة: sell BTCUSDT id=TV_X → تُفتح Short مستقلة عن الـ Long حتى مع نفس id. الارتباط بـ id يُستخدم للإدارة، وليس لدمج الاتجاهين.
- تلميحات تنفيذية
    - اربط id بالـ position_id داخليًا، لكن حافظ على فصل الاتجاهات.
    - فعّل Reduce-Only عند الإغلاقات الشرطية في Futures.
    - أبقِ إشعارات التليغرام بدون ذكر نوع الحساب.
- الفكرة الأساسية
    - كل إشارة تحمل id فريد. عند link_by_id=True، تُعامل الإشارات ذات نفس id كصفقة واحدة مستمرة.
- سير العمل المختصر
    
    1) استلام الإشارة من TradingView → التحقق من schema.
    
    2) تحديد الحساب النشط: Demo/Real ثم Spot/Futures.
    
    3) البحث محليًا عن صفقة بنفس id وحالة الرمز.
    
    4) تطبيق المنطق:
    
    - buy: فتح أو تعزيز الصفقة ذات id.
    - sell (Futures): فتح/تعزيز Short ضمن نفس id أو تجاهل إذا يعاكس وضع Spot.
    - close: إغلاق كامل للصفقة المرتبطة بـ id.
    - partial_close: تقليص جزء من مركز id.
    
    5) تنفيذ Demo داخليًا أو إرسال أمر API في Real.
    
    6) تحديث السجلات ثم إشعار التليغرام بدون إظهار نوع الحساب.
    
- خرائط البيانات Data Mapping
    - id ↔ position_id الداخلي
    - symbol ↔ زوج التداول في المنصة
    - side ↔ Long/Short للـ Futures أو Buy/Sell للـ Spot
    - qty/size ↔ الكمية الفعلية أو المحسوبة من الإعدادات
    - flags ↔ Reduce-Only و Close-On-Trigger عند الإغلاق
- أمثلة طلبات API مبسطة

```json
{
  "action": "place_order",
  "account": "real",
  "market": "futures",
  "symbol": "BTCUSDT",
  "side": "Buy",
  "type": "Market",
  "size": 0.01,
  "link_id": "TV_B01",
  "reduce_only": false
}
```

```json
{
  "action": "close_partial",
  "account": "real",
  "market": "futures",
  "symbol": "BTCUSDT",
  "link_id": "TV_B01",
  "percentage": 50,
  "reduce_only": true,
  "close_on_trigger": true
}
```

- حالات الحافة Edge Cases
    - تكرار نفس الإشارة: افحص التكرار عبر طابع زمني وnonce لتجنّب التنفيذ المزدوج.
    - اختلاف الاتجاه مع نفس id: تجاهُل أو إنشاء id جديد حسب الإعدادات.
    - عدم كفاية رصيد Spot: منع التنفيذ وإرسال إشعار خطأ.
    - تعذّر API: إعادة المحاولة مع backoff وتبديل إلى مسار أمان.

---

### 13) سياسات مطابقة لفكرتك

### 12.2) تصحيح منطق الـ ID حسب طلبك

- تكرار الـ id لا يعني الإغلاق تلقائيًا.
- الإغلاق لا يحدث إلا إذا كانت الإشارة نوعها صراحة: close أو partial_close أو أوامر إدارة مثل TP/SL مذكورة بوضوح.
- حالات صحيحة:
    - buy بنفس الرمز ونفس id → تعزيز نفس الصفقة، وليس إغلاقها.
    - sell في Spot بنفس id لصفقة شراء Spot → يُعامل كبيع من الرصيد فقط، ولا يغلق تلقائيًا إلا إذا كان signal=close أو partial_close محددًا.
    - sell في Futures بنفس id لصفقة Long → تُفتح صفقة Short مستقلة. لا يُغلق Long إلا بإشارة close أو partial_close على id الخاص بالـ Long.
- الهدف من id: استهداف صفقة بعينها للإدارة عند إرسال إشارات إدارة مثل close أو partial_close أو TP/SL، وليس الإغلاق عند تكرار id.
- عدم إظهار نوع الحساب في أي إشعار خارجي.
- إبقاء Spot و Futures في عزلة منطقية. تبديل الحساب لا يغلق صفقات الحساب الآخر.
- الالتزام بـ link_by_id لتجميع التعزيز والإغلاق الجزئي ضمن نفس الهوية.
- تفعيل Reduce-Only لكل أوامر الإغلاق في Futures بشكل افتراضي.
- دعم OCO للـ TP/SL عند التفعيل. قيم افتراضية من الإعدادات مع قابلية التخصيص.
- تسجيل شامل: كل طلب، رد، حالة محلية، ولُبّ القرارات لغايات التتبّع.

---

### 14) سيناريوهات عملية كاملة

- سيناريو A: شراء ثم تعزيز ثم إغلاق جزئي Spot
    
    1) buy BTCUSDT id=TV_B01
    
    2) buy BTCUSDT id=TV_B01 (تعزيز نفس الهوية)
    
    3) partial_close 30% id=TV_B01
    
    - المنطق: دمج الكميات تحت نفس id. الإغلاق الجزئي يخفض الكمية وفق النسبة. يمنع بيع بدون رصيد.
- سيناريو B: فتح Short في Futures مع TP/SL مرفقين
    
    1) sell BTCUSDT id=TV_S11 → أمر Market مع تعيين رافعة وحساب Isolated
    
    2) ضبط OCO: TP عند +2% و SL عند -1%
    
    3) partial_close 50% عند وصول الهدف الأول
    
    - المنطق: استخدام Reduce-Only لكل أوامر الإغلاق. إبقاء إشعارات التليغرام بلا ذكر نوع الحساب.
- سيناريو C: تضارب اتجاه مع نفس id
    - حالة: توجد Long id=TV_X1 ثم تصل إشارة sell بنفس id
    - السياسة: تجاهل الإشارة أو فتح id جديد حسب الإعدادات. الافتراضي: تجاهل لتفادي انعكاس مفاجئ.

### 15) مخطط قرارات مبسط (Pseudo-Flow)

```jsx
function on_signal(sig) {
  assert(schema_ok(sig));

  const ctx = resolve_context({ account_type, market }); // Demo/Real + Spot/Futures
  let pos = find_position(ctx, [sig.id](http://sig.id)); // returns null if not found

  switch (sig.signal) {
    case 'buy': {
      if (market === 'spot') {
        if (link_by_id && pos) {
          enhance_spot(pos, compute_qty(sig));
        } else {
          open_spot(ctx, compute_qty(sig));
        }
      } else { // futures
        if (link_by_id && pos) {
          enhance_futures(pos, { side: 'Long', qty: compute_qty(sig) });
        } else {
          open_futures(ctx, { side: 'Long', qty: compute_qty(sig), tif: 'GTC' });
        }
      }
      break;
    }

    case 'sell': {
      if (market === 'spot') {
        sell_from_balance_or_reject(ctx, compute_qty(sig)); // no shorting on spot
      } else { // futures short
        if (link_by_id && pos) {
          enhance_futures(pos, { side: 'Short', qty: compute_qty(sig) });
        } else {
          open_futures(ctx, { side: 'Short', qty: compute_qty(sig), tif: 'GTC' });
        }
      }
      break;
    }

    case 'close': {
      require_position(pos);
      close_full(pos, { reduce_only: true, close_on_trigger: true });
      break;
    }

    case 'partial_close': {
      require_position(pos);
      close_partial(pos, { pct: sig.percentage, reduce_only: true, close_on_trigger: true });
      break;
    }

    default:
      throw new Error('unsupported signal type');
  }

  persist_state(ctx);
  notify_telegram({ mask_account_type: true, link_id: [sig.id](http://sig.id) });
}
```

### 16) قائمة تحقق قبل النشر

- التحقق من مفاتيح API وصلاحياتها المحدودة
- إعداد الرافعة الافتراضية وحدود الحجم لكل رمز
- تفعيل سياسات Retry و Backoff لأخطاء الشبكة
- اختبار Edge Cases: تكرار الإشارة، عدم كفاية الرصيد، زمن استجابة بطيء
- مراجعة تنسيق الإشعارات وإخفاء نوع الحساب
- تمكين سجلات تفصيلية مع تتبّع link_id

### 17) ملحق التعاريف المختصرة

- link_by_id: تجميع الإشارات بنفس الهوية كصفقة واحدة
- Reduce-Only: أمر لا يزيد الحجم إطلاقًا ويستخدم للإغلاق فقط
- Close-On-Trigger: حماية تمنع زيادة المخاطر عند تفعيل أوامر الشرط
- OCO: أمران مترابطان للهدف ووقف الخسارة، تنفيذ أحدهما يلغي الآخر
- Time in Force: سياسة بقاء الأمر GTC أو IOC أو FOK

---

ملاحظة: تحقّق دائمًا من المعلومات الحساسة قبل التنفيذ. قد تحدث أخطاء من نموذج الذكاء الاصطناعي، لذا يفضّل التحقق من الإعدادات والمعايير الحرجة.

---